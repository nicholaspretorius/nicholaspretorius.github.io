{"data":{"markdownRemark":{"html":"<p>Below are some useful commands when working with Terraform, KubeOne, Kubernetes and EKS:</p>\n<h3>Terraform</h3>\n<p>Note that the [default] AWS credentials are used from <code>~/aws/credentials</code>: </p>\n<p><code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> need to be specified as environment variables in your Terminal. Instead of manually setting these in each Terminal session, you can add these to: </p>\n<p><code>~/.bashrc</code></p>\n<p>Then, from the command line, run: </p>\n<p><code>source ~/.bashrc</code> </p>\n<p>This will activate the latest vars for your Terminal. </p>\n<h4>SSH</h4>\n<p>You need an SSH key to successfully run the Terraform commands. </p>\n<p>Take a look <a href=\"https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">here</a> for background on how to add your SSH key.</p>\n<ul>\n<li>Start SSH agent in background: </li>\n</ul>\n<p><code>eval \"$(ssh-agent -s)\"</code></p>\n<ul>\n<li>Add SSH key to ssh-agent and store passphrase in keychain:</li>\n</ul>\n<p><code>ssh-add -K ~/.ssh/id_rsa</code></p>\n<p>Commands to run in order to setup KubeOne on AWS infrastructure via Terraform: </p>\n<ul>\n<li>Check Terraform version: </li>\n</ul>\n<p><code>terraform version</code></p>\n<ul>\n<li>Check KubeOne version</li>\n</ul>\n<p><code>kubeone version</code></p>\n<ul>\n<li>Initialise Terraform from folder containing Terraform files</li>\n</ul>\n<p><code>cd/terraform &#x26;&#x26; terraform init</code></p>\n<ul>\n<li>Shows what Terraform will setup for you: </li>\n</ul>\n<p><code>terraform plan</code></p>\n<ul>\n<li>Outputs a non-human readable Terraform plan: </li>\n</ul>\n<p><code>terraform plan -out plan</code> </p>\n<ul>\n<li>In order to see what the plan outputs, run the following command: </li>\n</ul>\n<p><code>terraform show -json plan</code></p>\n<ul>\n<li>Terraform will create the infrastructure required:</li>\n</ul>\n<p><code>terraform apply</code></p>\n<ul>\n<li>Output Terraform config:</li>\n</ul>\n<p><code>terraform output -json > tf.json</code></p>\n<ul>\n<li>Reset k8s according to Terraform (see notes below on how to setup the k8s on the TF infrastructure):</li>\n</ul>\n<p><code>kubeone reset ./terraform/config.yaml --tfjson ./terraform/tf.json</code> </p>\n<ul>\n<li>Destroy all terraform infrastructure setup by Terraform:</li>\n</ul>\n<p><code>terraform destroy</code> </p>\n<h3>Kubernetes, KubeOne</h3>\n<ul>\n<li><code>kubectl version</code> </li>\n<li>Configure k8s cluster according to Terraform (as defined above): </li>\n</ul>\n<p><code>kubeone install config.yaml --tfjson tf.json</code></p>\n<ul>\n<li>Export kubeconfig to env vars: </li>\n</ul>\n<p><code>export KUBECONFIG=$PWD/projectname-kubeconfig</code></p>\n<ul>\n<li>\n<p><code>kubectl get secrets</code> </p>\n</li>\n<li>\n<p>Create env secrets: </p>\n</li>\n</ul>\n<p><code>kubectl create secret generic env-secret --from-literal=DB_USER='dbusernamehere' --from-literal=DB_PASS='dbpasshere' --from-literal=JWT_SECRET='jwtsecrethere'</code></p>\n<ul>\n<li>Create AWS secrets: </li>\n</ul>\n<p><code>kubectl create secret generic aws-secret --from-literal=aws_access_key_id='awssecretkeyhere' --from-literal=aws_secret_access_key='awssecretaccesskeyhere'</code> </p>\n<ul>\n<li>Delete secret: </li>\n</ul>\n<p><code>kubectl delete secrets env-secret.yaml</code></p>\n<ul>\n<li>Get k8s cluster info: </li>\n</ul>\n<p><code>kubectl cluster-info</code></p>\n<ul>\n<li>View k8s config info: </li>\n</ul>\n<p><code>kubectl config view</code></p>\n<ul>\n<li>View k8s nodes:</li>\n</ul>\n<p><code>kubectl get nodes</code></p>\n<ul>\n<li>View k8s services: </li>\n</ul>\n<p><code>kubectl get service client -o wide</code></p>\n<h3>EKS (Elastic Kubernetes Service)</h3>\n<ul>\n<li>Create cluster on AWS via EKS according to config: </li>\n</ul>\n<p><code>eksctl create cluster -f cluster.yaml</code></p>\n<ul>\n<li>Create cluster by default: </li>\n</ul>\n<p><code>eksctl create cluster --name projectname-here</code></p>\n<ul>\n<li>Add CloudWatch: </li>\n</ul>\n<p><code>eksctl utils update-cluster-logging --region=eu-west-1 --cluster=projectname-here</code></p>\n<ul>\n<li>Create cluster with details: </li>\n</ul>\n<p><code>eksctl create cluster --name=projectname-here --nodes=3 --managed --alb-ingress-access --region=${AWS_REGION}</code></p>\n<ul>\n<li>Delete cluster: </li>\n</ul>\n<p><code>eksctl delete cluster --name=name-here</code></p>\n<h3>k8s</h3>\n<p>In order to create your configmaps, deployments and services, run the following: </p>\n<ul>\n<li>Create configmap: </li>\n</ul>\n<p><code>kubectl apply -f ./path/to/k8sfiles/env-configmap.yaml</code> </p>\n<ul>\n<li><code>kubectl get configmaps</code></li>\n<li>Create deployment: </li>\n</ul>\n<p><code>kubectl apply -f ./path/to/k8sfiles/appname.deployment.yaml</code></p>\n<ul>\n<li><code>kubectl get deployments</code></li>\n<li><code>kubectl get pods</code></li>\n<li><code>kubectl describe pods podnamehere</code></li>\n<li><code>kubectl logs podname-7bdc944cdb-kn9wv</code></li>\n<li><code>kubectl apply -f ./path/to/k8sfiles/appname.service.yaml</code></li>\n<li>Change apiVersion: </li>\n</ul>\n<p><code>kubectl convert -f ./path/to/k8sfiles/appname.deployment.yaml --output-version apps/v1</code></p>\n<ul>\n<li><code>kubectl get services</code></li>\n<li><code>kubectl get pods -o wide</code></li>\n<li>Get container port: </li>\n</ul>\n<p><code>kubectl get pods podname-7bdc944cdb-s7d4n --template='{{(index (index .spec.containers 0).ports 0).containerPort}}{{\"\\n\"}}'</code></p>\n<ul>\n<li>Get replica sets: </li>\n</ul>\n<p><code>kubectl get rs</code></p>\n<ul>\n<li><code>kubectl port-forward services/servicename 8080:8080</code></li>\n<li><code>kubectl port-forward services/servicename 8100:8100</code></li>\n<li>To run in background, then press <code>fg</code> to get it back into foreground: </li>\n</ul>\n<p><code>kubectl port-forward services/servicename 8080:8080 &#x26;</code> </p>\n<ul>\n<li><code>kubectl get machinedeployments -n kube-system</code></li>\n<li>Scale up: </li>\n</ul>\n<p><code>kubectl scale machinedeployment/projectname-eu-west-1a -n kube-system --replicas=2</code></p>\n<ul>\n<li>Scale down: </li>\n</ul>\n<p><code>kubectl scale machinedeployment/projectname-eu-west-1a -n kube-system --replicas=0</code></p>\n<ul>\n<li><code>kubectl delete -f ./path/to/k8sfiles/appname.service.yaml</code></li>\n<li><code>kubectl delete -f ./path/to/k8sfiles/appname.deployment.yaml</code></li>\n</ul>\n<p>Useful commands from k8s Tutorials:</p>\n<ul>\n<li>Rolling update: </li>\n</ul>\n<p><code>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</code> </p>\n<ul>\n<li><code>kubectl describe services/kubernetes-bootcamp</code></li>\n<li><code>export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}'</code></li>\n<li><code>echo NODE_PORT=$NODE_PORT</code></li>\n<li><code>curl $(minikube ip):$NODE_PORT</code></li>\n<li><code>kubectl rollout status deployments/kubernetes-bootcamp</code></li>\n<li><code>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10</code> fetch image that does not exist...</li>\n<li><code>kubectl get deployments</code> see not all are ready...</li>\n<li><code>kubectl get pods</code> will show new pods erroring...</li>\n<li><code>kubectl rollout undo deployments/kubernetes-bootcamp</code> undo rollout... </li>\n<li><code>kubectl get pods</code> back to normal, only running pods</li>\n<li><code>kubectl expose deployment/kubernetes-bootcamp --type=\"NodePort\" --port 8080</code> expose service </li>\n<li><code>kubectl get services</code> view service details</li>\n<li><code>kubectl describe services/kubernetes-bootcamp</code> see further details</li>\n<li><code>export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')</code></li>\n<li><code>echo NODE_PORT=$NODE_PORT</code></li>\n<li><code>curl $(minikube ip):$NODE_PORT</code></li>\n<li><code>kubectl describe deployment</code> describe deployment, take not of the \"label\" field, which is run=kubernetes-bootcamp</li>\n<li><code>kubectl get pods -l run=kubernetes-bootcamp</code> get pods with that label (-l)</li>\n<li><code>kubectl get services -l run=kubernetes-bootcamp</code> can use for services too</li>\n<li><code>export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{\"\\n\"}}{{end}}')</code> store pod name</li>\n<li><code>echo Name of the Pod: $POD_NAME</code> display pod name</li>\n<li><code>kubectl label pod $POD_NAME app=v1</code> give pod a new label</li>\n<li><code>kubectl describe pods $POD_NAME</code> see pod has nee label</li>\n<li><code>kubectl get pods -l app=v1</code> query with new label</li>\n<li><code>kubectl delete service -l run=kubernetes-bootcamp</code> delete service</li>\n<li><code>kubectl get services</code> see NodePort service no longer available</li>\n<li>Failed to connect (since it no longer exists): </li>\n</ul>\n<p><code>curl $(minikube ip):$NODE_PORT</code></p>\n<ul>\n<li>Confirm app is still running on internal cluster: </li>\n</ul>\n<p><code>kubectl exec -ti $POD_NAME curl localhost:8080</code></p>\n<p>Further notes on k8s:</p>\n<p>When you see values \"port\" and \"targetPort\". \"port\" is the port on the external IP, \"targetPort\" is the port on the container. </p>\n<p><code>port-forward</code> is only a means of debugging, it is not a practical means of making containers available. </p>","frontmatter":{"title":"Terraform, Kubernetes and EKS Command Cheat Sheet."}}},"pageContext":{"slug":"/til0161/"}}