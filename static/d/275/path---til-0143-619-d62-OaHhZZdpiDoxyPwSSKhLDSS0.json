{"data":{"markdownRemark":{"html":"<p>On a recent project, I have been using <a href=\"http://flask-restplus.readthedocs.io/\">Flask-RESTplus</a> for building and auto-documenting an API. Flask-RESTplus comes with <a href=\"https://swagger.io/\">Swagger</a> integration out the box and works in a similar way to <a href=\"https://flask-restful.readthedocs.io/en/latest/\">Flask-RESTful</a>. </p>\n<p>Unlike <a href=\"https://www.palletsprojects.com/p/flask/\">Flask</a>, which uses decorators with functions to describe API resources. Flask-RESTplus (and Flask-RESTful) use Python classes along with decorators to represent your API resources. </p>\n<p>I had a decorator from a previous Flask project that I wanted to re-use in my Flask-RESTplus API and was curious about how easily the implementation would carry over. The decorator (@requires_auth) checks that the user is authorised in order to view the endpoint. In Flask, this would look something like this:</p>\n<pre><code>...\n@app.route('/protected-resource', methods=['GET'])\n@requires_auth('get:protected-resources')\ndef retrieve_protected(payload):\n    try:\n        ... code goes here...\n    except AuthError:\n        abort(401)\n\n...\n</code></pre>\n<p>As you can see, the route and methods are specified in the route decorator and the functionality is then defined in a function. </p>\n<p>To achieve the same result in Flask-RESTplus, you would do the following with the route specified in the decorator and the class using functions to define the API methods: </p>\n<pre><code>...\n@api.route(\"/protected\")\nclass Protected(Resource):\n    @requires_auth(\"get:protected-resources\")\n    def get(self, payload):\n        try:\n            ... code goes here ...\n        except AuthError:\n            return abort(401)\n...\n</code></pre>\n<p>I find this makes organising the routes a little more logical since you can group all the required API methods (GET, POST, DELETE, PUT etc) for a resource together in one class. </p>\n<p>As you can see, the approaches are very similar but slightly different. You still need to decorate the <em>function</em> defining the route. </p>\n<p>If you try to apply the decorator to the class, you will get an error saying: <code>AttributeError: 'function' object has no attribute 'as_view'</code></p>\n<p>There you have two ways of using the same decorator with Flask or Flask-RESTplus. </p>","frontmatter":{"title":"Using Decorators with Flask-RESTplus."}}},"pageContext":{"slug":"/til0143/"}}