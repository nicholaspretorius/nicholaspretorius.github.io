{"data":{"markdownRemark":{"html":"<p>Below are some useful commands when working with Terraform, Kubernetes and EKS:</p>\n<h3>Terraform</h3>\n<p>Note that the [default] AWS credentials are used from <code>~/aws/credentials</code>. i.e. AWS<em>ACCESS</em>KEY<em>ID and AWS</em>SECRET<em>ACCESS</em>KEY need to be specified as environment variables in your Terminal. Instead of manually setting these in each Terminal session, you can add these to: <code>~/.bashrc</code> and then, from the command line, run <code>source ~/.bashrc</code> in order to activate the latest vars there. </p>\n<h4>SSH</h4>\n<p>You need an SSH key to successfully run the Terraform commands. Take a look here for background on how to add your SSH key: <a href=\"https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>\n<ul>\n<li><code>eval \"$(ssh-agent -s)\"</code> start SSH agent in background</li>\n<li><code>ssh-add -K ~/.ssh/id_rsa</code> Add SSH key to ssh-agent and store passphrase in keychain</li>\n</ul>\n<p>Commands to run in order to setup KubeOne on AWS infrastructure via Terraform: </p>\n<ul>\n<li><code>terraform version</code> check Terraform version</li>\n<li><code>kubeone version</code> check KubeOne version</li>\n<li><code>cd/terraform &#x26;&#x26; terraform init</code> Initialise Terraform</li>\n<li><code>terraform plan</code> shows what Terraform will setup for you</li>\n<li><code>terraform plan -out plan</code> outputs a non-human readable Terraform plan, in order to see what the plan outputs, run the following command: </li>\n<li><code>terraform show -json plan</code></li>\n<li><code>terraform apply</code></li>\n<li><code>terraform output -json > tf.json</code></li>\n<li><code>kubeone reset ./terraform/config.yaml --tfjson ./terraform/tf.json</code></li>\n<li><code>terraform destroy</code> destroy all terraform infrastructure setup by Terraform</li>\n</ul>\n<h3>Kubernetes, KubeOne</h3>\n<ul>\n<li><code>kubectl version</code> check k8s version</li>\n<li><code>kubeone install config.yaml --tfjson tf.json</code> configure k8s cluster according to Terraform</li>\n<li><code>export KUBECONFIG=$PWD/projectname-kubeconfig</code> export kubeconfig to env vars</li>\n<li><code>kubectl get secrets</code> display secrets</li>\n<li><code>kubectl delete secrets env-secret.yaml</code> delete secret</li>\n<li><code>kubectl cluster-info</code> get k8s cluster info</li>\n<li><code>kubectl config view</code> view k8s config info</li>\n<li><code>kubectl get nodes</code> view k8s nodes</li>\n<li><code>kubectl get service client -o wide</code> view k8s services</li>\n</ul>\n<h3>EKS (Elastic Kubernetes Service)</h3>\n<ul>\n<li><code>eksctl create cluster -f cluster.yaml</code> create cluster on AWS via EKS</li>\n<li><code>eksctl create cluster --name projectname-here</code></li>\n<li><code>eksctl utils update-cluster-logging --region=eu-west-1 --cluster=projectname-here</code></li>\n<li><code>eksctl create cluster --name=projectname-here --nodes=3 --managed --alb-ingress-access --region=${AWS_REGION}</code></li>\n<li><code>eksctl delete cluster --name=name-here</code></li>\n</ul>\n<h3>k8s</h3>\n<p>In order to create your configmaps, deployments and services, run the following: </p>\n<ul>\n<li><code>kubectl apply -f ./path/to/k8sfiles/env-configmap.yaml</code> create configmap</li>\n<li><code>kubectl get configmaps</code></li>\n<li><code>kubectl apply -f ./path/to/k8sfiles/appname.deployment.yaml</code> create deployment</li>\n<li><code>kubectl get deployments</code></li>\n<li><code>kubectl get pods</code></li>\n<li><code>kubectl describe pods podnamehere</code></li>\n<li><code>kubectl logs podname-7bdc944cdb-kn9wv</code></li>\n<li><code>kubectl apply -f ./path/to/k8sfiles/appname.service.yaml</code></li>\n<li><code>kubectl convert -f ./path/to/k8sfiles/appname.deployment.yaml --output-version apps/v1</code> change apiVersion</li>\n<li><code>kubectl get services</code></li>\n<li><code>kubectl get pods -o wide</code></li>\n<li><code>kubectl get pods podname-7bdc944cdb-s7d4n --template='{{(index (index .spec.containers 0).ports 0).containerPort}}{{\"\\n\"}}'</code> get container port</li>\n<li><code>kubectl get rs</code> get replica sets</li>\n<li><code>kubectl port-forward services/servicename 8080:8080</code></li>\n<li><code>kubectl port-forward services/servicename 8100:8100</code></li>\n<li><code>kubectl port-forward services/servicename 8080:8080 &#x26;</code> to run in background, then press <code>fg</code> to get it back into foreground</li>\n<li><code>kubectl get machinedeployments -n kube-system</code></li>\n<li><code>kubectl scale machinedeployment/projectname-eu-west-1a -n kube-system --replicas=2</code> scale up</li>\n<li><code>kubectl scale machinedeployment/projectname-eu-west-1a -n kube-system --replicas=0</code> scale down</li>\n<li><code>kubectl delete -f ./path/to/k8sfiles/appname.service.yaml</code></li>\n<li><code>kubectl delete -f ./path/to/k8sfiles/appname.deployment.yaml</code></li>\n</ul>\n<p>Useful commands from k8s Tutorials:</p>\n<ul>\n<li><code>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</code> rolling update</li>\n<li><code>kubectl describe services/kubernetes-bootcamp</code></li>\n<li><code>export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}'</code></li>\n<li><code>echo NODE_PORT=$NODE_PORT</code></li>\n<li><code>curl $(minikube ip):$NODE_PORT</code></li>\n<li><code>kubectl rollout status deployments/kubernetes-bootcamp</code></li>\n<li><code>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10</code> fetch image that does not exist...</li>\n<li><code>kubectl get deployments</code> see not all are ready...</li>\n<li><code>kubectl get pods</code> will show new pods erroring...</li>\n<li><code>kubectl rollout undo deployments/kubernetes-bootcamp</code> undo rollout... </li>\n<li><code>kubectl get pods</code> back to normal, only running pods</li>\n<li><code>kubectl expose deployment/kubernetes-bootcamp --type=\"NodePort\" --port 8080</code> expose service </li>\n<li><code>kubectl get services</code> view service details</li>\n<li><code>kubectl describe services/kubernetes-bootcamp</code> see further details</li>\n<li><code>export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')</code></li>\n<li><code>echo NODE_PORT=$NODE_PORT</code></li>\n<li><code>curl $(minikube ip):$NODE_PORT</code></li>\n<li><code>kubectl describe deployment</code> describe deployment, take not of the \"label\" field, which is run=kubernetes-bootcamp</li>\n<li><code>kubectl get pods -l run=kubernetes-bootcamp</code> get pods with that label (-l)</li>\n<li><code>kubectl get services -l run=kubernetes-bootcamp</code> can use for services too</li>\n<li><code>export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{\"\\n\"}}{{end}}')</code> store pod name</li>\n<li><code>echo Name of the Pod: $POD_NAME</code> display pod name</li>\n<li><code>kubectl label pod $POD_NAME app=v1</code> give pod a new label</li>\n<li><code>kubectl describe pods $POD_NAME</code> see pod has nee label</li>\n<li><code>kubectl get pods -l app=v1</code> query with new label</li>\n<li><code>kubectl delete service -l run=kubernetes-bootcamp</code> delete service</li>\n<li><code>kubectl get services</code> see NodePort service no longer available</li>\n<li><code>curl $(minikube ip):$NODE_PORT</code> failed to connect (since it no longer exists)</li>\n<li><code>kubectl exec -ti $POD_NAME curl localhost:8080</code> confirm app is still running on internal cluster</li>\n</ul>\n<p>Further notes on k8s:</p>\n<p>When you see values \"port\" and \"targetPort\". \"port\" is the port on the external IP, \"targetPort\" is the port on the container. </p>\n<p><code>port-forward</code> is only a means of debugging, it is not a practical means of making containers available. </p>","frontmatter":{"title":"Terraform, Kubernetes and EKS Command Cheat Sheet."}}},"pageContext":{"slug":"/til0161/"}}