{"version":3,"sources":["webpack:///path---til-0044-232758071eebe267ba9e.js","webpack:///./.cache/json/til-0044.json"],"names":["webpackJsonp","468","module","exports","data","markdownRemark","html","frontmatter","title","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,iyCAAAC,aAAuzCC,MAAA,cAAqBC,aAAgBC,KAAA","file":"path---til-0044-232758071eebe267ba9e.js","sourcesContent":["webpackJsonp([281334771258550],{\n\n/***/ 468:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Liferay on Azure</h3>\\n<p>I spent some time today getting to grips with the pricing structures on Azure in terms of putting together a proof of concept for running a Liferay application in our Azure PoC environments. Liferay is a Java-based CMS running a Postgres database, on an Apache Tomcat server and interestingly, Elasticsearch. I have previously setup a small Java microservice on Azure before and enjoyed the experience, so this has been an interesting exercise. </p>\\n<p>At present, the decision we face is how to set the stack up. The options as I see them are: </p>\\n<ul>\\n<li>Run the application in a VM with a Bitnami Liferay image as well as an Elasticsearch image. I am not sure this will be cost-effective since the team is already under a lot of pressure and running their own stack within the VM might not be the best option. </li>\\n<li><em>Manually</em> set the stack up inside a VM, however, this may also be a challenge since the team is not experienced in devops culture and running what gets built. </li>\\n<li>Find a way to run the app inside an App Service with a managed instance of Postgres along with blob storage and a CDN. </li>\\n</ul>\\n<p>I am still investigating the options, but I am excited about the possibilities and options for expanding my Azure knowledge further! </p>\",\"frontmatter\":{\"title\":\"TIL 0044\"}}},\"pathContext\":{\"slug\":\"/til0044/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---til-0044-232758071eebe267ba9e.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Liferay on Azure</h3>\\n<p>I spent some time today getting to grips with the pricing structures on Azure in terms of putting together a proof of concept for running a Liferay application in our Azure PoC environments. Liferay is a Java-based CMS running a Postgres database, on an Apache Tomcat server and interestingly, Elasticsearch. I have previously setup a small Java microservice on Azure before and enjoyed the experience, so this has been an interesting exercise. </p>\\n<p>At present, the decision we face is how to set the stack up. The options as I see them are: </p>\\n<ul>\\n<li>Run the application in a VM with a Bitnami Liferay image as well as an Elasticsearch image. I am not sure this will be cost-effective since the team is already under a lot of pressure and running their own stack within the VM might not be the best option. </li>\\n<li><em>Manually</em> set the stack up inside a VM, however, this may also be a challenge since the team is not experienced in devops culture and running what gets built. </li>\\n<li>Find a way to run the app inside an App Service with a managed instance of Postgres along with blob storage and a CDN. </li>\\n</ul>\\n<p>I am still investigating the options, but I am excited about the possibilities and options for expanding my Azure knowledge further! </p>\",\"frontmatter\":{\"title\":\"TIL 0044\"}}},\"pathContext\":{\"slug\":\"/til0044/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/til-0044.json\n// module id = 468\n// module chunks = 281334771258550"],"sourceRoot":""}